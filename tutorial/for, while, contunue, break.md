# For迴圈

``<> - 必填參數 - 一定要填寫的參數``

``[] - 選填參數 - 不一定要填的參數``

# 語法-第一種
```
for 變數名稱 in range([起始值], <終止值>,[遞增/遞減值]):
    <Code>
```

## 變數名稱
變數名稱可以隨便寫，

設定為i, j, a, fbk都可以，

為了方便，以下範例都會以``i``作為變數名稱。

## 終止值
必須填寫的參數。

決定迴圈的終止值。迴圈在跑的時候，變數``i``不會跑到等於終止值，遞增情況下不會大於等於終止值，遞減情況下不會小於等於終止值，一定會在終止值之前停下來。

## 起始值
決定迴圈的起始值。

迴圈在跑的時候，i將會由設定的起始值開始遞增或遞減。


例如：起始值設定為5，i就會從5開始跑(遞增或是遞減)。

起始值可以不指定，不指定時將會採預設值0。

## 遞增/遞減值
決定迴圈的遞增/遞減值。

迴圈跑的時候，i會以設定的遞增/遞減值，跑一次就增加或是減少數值。

輸入正數，i就會遞增。

輸入負數，i就會遞減。

如果不指定，就會採用預設值1。


例如:起始值不指定，終止值設為5，遞增/遞減值設為1。

i將會從0開始跑，每跑一次就加1(0 1 2 3 4)，最後跑到4結束，迴圈共跑5次。


``for i in range(0, 5, 1)``


那如果我把遞增/遞減值改成負數？


例如:起始值設定為10，終止值設為1，遞增/遞減值設為-1。

i將會從10開始跑，每跑一次就減1(10 9 8 7 6 5 4 3 2)，也就是遞減1，最後跑到2結束，迴圈共跑9次。


``for i in range(10, 1, -1)``


## 更多範例
接下來會講解一些奇奇怪怪的狀況。

## 如果我只給一個參數
假設我程式碼打這樣：

``for i in range(5)``

因為終止值是必填參數，唯一有填的參數(5)就會作為終止值，而起始值跟遞增/遞減值則視為不指定，採用預設值。

## 如果我只給兩個參數
假設我程式碼打這樣

``for i in range(1, 5)``

第一個參數(1)會被作為起始值，第二個參數(5)就會作為終止值，而遞增/遞減值則視為不指定，採用預設值。

## 如果我給滿三個參數
那就跟上面寫的標準語法一樣，三個參數也都會被視為有指定，並採用你給的數值。

## 解釋一下上面說的"停在終止值之前"
如果我遞增值設定為1，i將會一直加1，並在終止值之前停下，即停在(終止值-1)。

如果我遞增值設定為-1，i將會從起始值開始一直減1，並在終止值之前停下，即停在(終止值+1)。


例如我將終止值設定為5，起始值設定為0，遞增/遞減值設定為1。

i會從0開始跑，每跑一次就加1，直到跑到i=4。

這個時候如果i再加1就會變成5，就等於終止值了，就爆掉了，所以i跑到等於4就會停止。

最後迴圈會跑5次，i則會從0跑到4停止(0、1、2、3、4)。


## 如果我的遞增遞減值不是1或是-1
假設我將起始值定為0，終止值定為11，遞稱/遞減值設定為2，意即迴圈每跑一次，i就會加2。因此i會從0變成2，再到4、6、8、10。

但是到10之後，如果再加2，就會變成12，超過設定的終止值11，因此i遞增到10的時候，迴圈就會停止，避免遞增到爆掉(超過或等於設定的終止值)，而迴圈最終會執行6次。

遞減也是同樣，不會遞減到比設定的終止值還小，一定會在終止值之前就停下來，避免遞減到爆掉(遞減到等於終止值或是比終止值還小)。


# 那你有發現第一種的for迴圈可以用來幹嘛嗎?
## ex.01-指定迴圈執行的次數
在不設定起始值、遞增/遞減值的情況下，終止值決定了這個迴圈會跑幾次，以及i會遞增到多少。


這裡給一個範例：白上吹雪真的很可愛，所以我想寫一個程式，可以顯示``FBK so cute``1005次。

```
for i in range(1005): print("FBK so cute")
```

在這個範例中，i會從0開始跑，迴圈每跑一次i就遞增1，直到i遞增到1004停止，最後迴圈會跑1005次，i從0跑到1004。


## ex.02-讓i在一個範圍裡面跑
設定起始值和終止值，可以讓i從起始值開始遞增或是遞減，最後在終止值之前停下來。


我想寫一個程式，會顯示出5~100的數字。

```
for i in range(5, 101): print(i)
```

在這個範例中，i會從5開始跑，迴圈每跑一次i就遞增1，直到i遞增到100為止，最後i會從5跑到100，畫面上也會顯示出5~100的數字。


## ex.03-倒數
我們知道for迴圈不只可以遞增，也可以遞減。


所以我可以寫一個程式，讓這個程式從10倒數到0，並且顯示出來。

```
for i in range(10, -1, -1): print(i)
```

在這個範例中，起始值被設定為10，終止值被設定為-1，遞增/遞減值被設定為-1。

所以這個迴圈的i會從10開始跑，每跑一次i就會遞減1，所以迴圈跑一次，i就會減1，直到i=0的時候，因為i這個時候再減1就會等於終止值``-1``，就會爆掉，所以跑到i=0的時候迴圈就會停止。

最後i會從10開始跑，跑到0結束(10、9、8、7、6、5、4、3、2、1、0)。畫面上也會顯示出i的數值變化。


## ex.04-印出1到100所有偶數
上面的奇妙範例告訴我們：遞增/遞減值不只可以設定成1或是-1。


所以我們可以寫一個程式，顯示出1到100之間的所有偶數。

```
for i in range(2, 101, 2): print(i)
```

在這個範例中，起始值被設定為2，終止值被設定為101，遞增/遞減值被設定為2。

所以i會從2開始跑，每跑一次i就會加2，直到跑到100，因為i=100的時候再加2就會爆掉(變成102，超過設定的終止值101)，所以i=100的時候迴圈就會停止。

最後i從2開始，每跑一次就加2，跑到i=100停止(2、4、6、．．．、96、98、100)。

# 語法-第二種
```
for 變數名稱 in 串列:
  <Code>
```
## 變數名稱
一樣，你想取啥名字都行，但我還是一樣會在範例中使用``i``作為變數名稱。

## 串列
就是放一個串列在那裏

> 定義一個串列
> a = [元素1, 元素2, 元素3, ...]

## 這樣搞有什麼效果
迴圈會從你給的串列取得元素，並依照順序指派到你設定的變數中，並重複執行你打的程式碼。

這樣講有些抽象，不如就打個實際的程式碼吧。

先設定一個串列：
```
a = ["FBK", "the", "cuttest", "fox"]
```

接著打一個程式碼：

```
for i in a: print(i)
```

在這個程式碼中，我把我的變數設定為i，我給的串列是a。

迴圈在跑的時候，會將串列``a``中的元素依序指派給變數``i``。

迴圈會先從串列中的第0個元素開始跑，跑到串列的最後一個元素。

迴圈執行幾次，則取決於串列有多長。


如果還是有點抽象，那我就把每次執行的狀況給打出來。

因為串列a只有4個元素，因此這個範例迴圈只會執行4次。

迴圈會從串列的第0個元素開始跑，直到跑到串列的第3個元素(最後一個元素)，總共跑4次。


**[串列開始執行]**

第1次跑的時候，串列中的第0個元素``"FBK"``會被指派給變數i，所以i會變成``"FBK"``，接著執行程式碼``print(i)``，所以i會被輸出，顯示出``FBK``。

第2次跑的時候，串列中的第1個元素``"the"``會被指派給變數i，所以i會變成``"the"``，接著執行程式碼``print(i)``，所以i會被輸出，顯示出``the``。

第3次跑的時候，串列中的第2個元素``"cuttest"``會被指派給變數i，所以i會變成``"cuttest"``，接著執行程式碼``print(i)``，所以i會被輸出，顯示出``cuttest``。

第4次跑的時候，串列中的第3個元素``"fox"``會被指派給變數i，所以i會變成``"fox"``，接著執行程式碼``print(i)``，所以i會被輸出，顯示出``fox``。

**[串列結束]**


從這個範例中我們可以看出，串列中的元素會被從串列的第0個元素到最後一個元素，依序指派給變數i，並重複執行迴圈中的程式碼。


參考資料:
1. https://medium.com/ccclub/ccclub-python-for-beginners-tutorial-4990a5757aa6

# while迴圈
## 語法
```
while 條件:
  <Code>
```
## while迴圈的條件
條件可以放入布林值(Bool)，就是True或是False。

也可以放入判斷式，判斷式執行之後會回傳布林值(True or False)到while迴圈。

## 這樣搞有什麼效果?
while迴圈在條件為True的時候會一直執行迴圈中的程式碼，直到條件變成False的時候，就會停止運作，離開迴圈。


這裡用一個範例程式碼來解釋：

```
i = 0
while i < 10:
  i += 1
  print(i)
```

在程式碼的第一行，定義了一個變數`i`，並將這個變數的值設為``0``。


在程式碼的第二行，寫了一個while迴圈，並將條件設定為``i < 10``，

這個判斷式白話講就是：當變數``i``的值小於10的時候，輸出True；如果沒有，就輸出False。

所以這個迴圈會一直跑，直到變數``i``不再小於10(等於10或是大於10)。


而程式碼的第三行和第四行則是迴圈的程式碼。

第三行會將i加上1；第四行則會輸出變數i的值，好讓我們觀察i的變化。


所以這個迴圈會不斷的將i加1，並輸出i的數值，直到i變成10的時候，因為i已經不再達成``i < 10``這個條件，判斷式輸出了False，迴圈就會結束執行。


## 無盡迴圈?
上面有講到，while迴圈的條件不僅可以放判斷式，也可以直接放布林值，也就是True跟False。

所以我們可以利用這個性質做一個無盡迴圈：

```
while True:
  <Code>
```

因為條件的部分一直是True，所以這個迴圈會一直執行，永不停止，直到碰到``break``、程式出錯，或是被直接關掉。


當然，你也可以寫一個``while False:``，但就是沒有啥屁用。


## 在條件的部分放一個變數
除了放判斷式跟直接放布林值之外，我們也可以定義一個值為布林值(True or False)的變數，並將這個變數作為while迴圈的條件。


```
running = True
while running:
  <Code>
```

在程式碼的第一行，定義了一個變數``running``，值設定為布林值``True``。

程式碼的第二行，寫了一個while迴圈``while running:``，條件設定為這個變數的值。

所以``running``變數的值為``True``時，迴圈就會一直執行，直到``running``變數變為False。

而我們也可以透過控制``running``變數的值去控制迴圈的執行。


# 巢狀迴圈
我們可以有不只一層的迴圈，我們可以迴圈包迴圈，就像大腸包小腸那樣。

這樣就會構成一個``巢狀迴圈``。


```
for i in range(1, 10):
  for j in range(1, 10):
    print("{} x {} = {}".format(i, j, i*j))
```

在這個範例中，就是一個for迴圈包著另一個for迴圈，構成一個雙層的巢狀迴圈。


不過這不代表只能包兩層，只要你夠閒，想包三層四層五層都可以。


也不代表只有for迴圈可以這樣搞，while迴圈也可以這樣搞。

```
i, j = 1, 1
while i<10:
    while j < 10:
        print("{} x {} = {}".format(i, j, i*j))
        j+=1
    print()
    j = 1
    i += 1
```

這個範例中，就是一個while迴圈包著另一個while迴圈，構成一個雙層的巢狀迴圈。


當然，你要while迴圈包for迴圈或是for迴圈包著while迴圈也可以。

```
j = 1
for i in range(1, 10):
    while j < 10:
        print("{} x {} = {}".format(i, j, i*j))
        j+=1
    print()
    j = 1
```

這個範例中，就是一個for迴圈包著一個while迴圈，構成一個雙層的巢狀迴圈。

# break 和 continue
## break
在迴圈中放入這個程式碼，當迴圈執行到這段程式碼的時候，就會**直接離開這個迴圈**，直接**結束這個迴圈**。

```
for i in range(1, 11): 
  if i == 6: break
  else: print(i)
```

在這個迴圈中，i會從1開始跑，直到跑到``i=10``結束迴圈。

迴圈中有一個``if``判斷式：

如果``i等於6``的時候，執行``break``程式；

否則，輸出``i``的數值。


那麼迴圈開始運作了，i從1開始跑，跑到2、3、4、5，因為i都不等於6，不滿足判斷式，所以都相安無事的輸出了i的數值。

但是，當i變成6的時候，因為滿足了判斷式``i==6``，所以執行了``break``，所以迴圈直接結束，沒有繼續執行。

最後只會輸出1、2、3、4、5。


## continue
在迴圈中放入這個程式碼，當迴圈執行到這段程式碼的時候，就會**跳過這一次的執行**。

但是不是直接結束迴圈，只是跳過這一次的執行，跳到下一次的執行。


```
for i in range(1, 11):
  if i == 6: continue
  else: print(i)
  print("=====")
```

這個程式碼中，有一個for迴圈，i會從1開始跑，直到跑到``i=10``結束迴圈。

迴圈中則是有一個判斷式：

當``i等於6``時，執行程式碼``continue``跳過這次執行。

否則，輸出``i``的數值。

判斷式下面還有一個程式，會輸出五個等號，作為分隔線。


那麼迴圈開始運作了，一開始，i從1開始跑，跑到2、3、4、5，因為都沒有達成if判斷式的``i==6``(i等於6)的這個條件，所以輸出了``i``的數值，接著往下執行，輸出分隔線。

但是，當i變成6的時候，因為滿足了判斷式i==6，所以執行了continue，所以迴圈跳過了這一次的執行，i的數值沒有被輸出，分隔線也沒有被輸出，i變成了7，接著繼續跑到i變成8、9、10，然後結束。

最後的輸出變成1、2、3、4、5、7、8、9、10。

你會發現輸出中跳過了6這個數字，這是因為跑到6的時候滿足了判斷式，執行了``continue``程式碼，那一次的執行就被跳過了，所以6就沒有被輸出。
